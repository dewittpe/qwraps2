#' @title Precision-Recall Curves
#'
#' @description Construction of Precision-Recall Curves (PRC)
#'
#' @details
#' Given a \code{glm} fit with \code{family = "binomial"} (either a log-link or
#' logit-link should be fine, a data set will be constructed and PRC plots
#' generated.
#'
#' The area under the curve (AUC) is determined by a trapezoid approximation.
#'
#' @param x a \code{glm} fit or \code{data.frame} generated by
#' \code{qprc_build_data_frame}.
#' @param n_threshold number of thresholds to test against.
#' @param ... passed to \code{stats::predict}
#'
#' @seealso \code{vignette("qwraps2-graphics", package = "qwraps2")} for more
#' examples.
#'
#' @return a ggplot.  Minimal aesthetics have been used so that the user may
#' modify the graphic as desired with ease.
#'
#' @examples
#' # load ggplot2 and the diamonds data set
#' data(diamonds, package = "ggplot2")
#'
#' # Create a logistic regression models
#' fit <- glm(I(price > 2800) ~ cut * color, data = diamonds, family = binomial())
#'
#' head(qprc_build_data_frame(fit))
#' auc(qprc_build_data_frame(fit))
#' qprc(fit)
#'
#' @export
#' @rdname qprc
qprc <- function(x, ...) {
  UseMethod("qprc")
}

#' @export
qprc.default <- function(x, ...) {
  qprc_ggplot(x)
}

#' @export
qprc.glm <- function(x, n_threshold = 200, ...) {
  auc_data <- qprc_build_data_frame(x, n_threshold, ...)
  qprc_ggplot(auc_data)
}

#' @export
qprc.qwraps2_generated <- function(x, ...) {
  qprc_ggplot(x)
}

qprc_ggplot <- function(data) {
  ggplot2::ggplot(data) +
  ggplot2::aes_string(x = "Recall", y = "Precision") +
  ggplot2::geom_line() +
  ggplot2::geom_hline(yintercept = attr(data, "baseline"), linetype = 2)
}

#' @export
#' @rdname qprc
#' @param fit a \code{glm} fit with \code{family = binomial()}.
qprc_build_data_frame <- function(fit, n_threshold = 200, ...) {

  # find the predicted values
  pred_vals <- stats::predict(fit, ..., type = "response")

  true_pos <- function(threshold){ sum((pred_vals >= threshold) &  (fit$y)) }
  true_neg <- function(threshold){ sum((pred_vals <  threshold) & !(fit$y)) }

  false_pos <- function(threshold){ sum((pred_vals >= threshold) & !(fit$y)) }
  false_neg <- function(threshold){ sum((pred_vals <  threshold) &  (fit$y)) }

  x <- matrix(seq(1, 0, length = n_threshold))

  true_positives  <- apply(x, 1, true_pos)
  true_negatives  <- apply(x, 1, true_neg)
  false_positives <- apply(x, 1, false_pos)
  false_negatives <- apply(x, 1, false_neg)

  Recall    <- true_positives / (true_positives + false_negatives) # aka sensitivity
  Precision <- true_positives / (true_positives + false_positives) # aka positive predictive power

  Precision[is.na(Precision)] <- stats::na.omit(Precision)[1]

  prc_data <- data.frame(Recall, Precision)

  # trapezoid rule approximation for the area under the curve
  auc <- sum((prc_data[2:n_threshold, 1] - prc_data[1:(n_threshold-1), 1]) * 1/2 *
             (prc_data[2:n_threshold, 2] + prc_data[1:(n_threshold-1), 2]))

  attr(prc_data, "baseline") <- mean(fit$y)
  attr(prc_data, "auc") <- auc
  class(prc_data)       <- c("qwraps2_generated", class(prc_data))

  return(prc_data)
}

